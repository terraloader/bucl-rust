# explode — split a string on a separator.
#
# Arguments: separator (arg 0), text to split (arg 1).
# Returns: array of parts (target variable becomes a multi-arg array).
# Side-effect: sets {target/0}, {target/1}, … to each part;
#              {target/count} holds the number of parts.
#
# Usage (positional):
#   {parts} explode "," "one,two,three"
#   # {parts/count} = "3"
#   # {parts/0} = "one"
#   # {parts/1} = "two"
#   # {parts/2} = "three"
#
# Usage (named):
#   {delimiter} = ","
#   {text} = "one,two,three"
#   {parts} explode {delimiter} {text}

if {delimiter} != ""
	{_sep} = {delimiter}
else
	{_sep} = {0}

if {text} != ""
	{_text} = {text}
else
	{_text} = {1}
{_sep_len} = {_sep/length}
{_text_len} = {_text/length}
{_count} = "0"
{_done} = "0"
{_remaining} = {_text}
{_concat} = ""

# We need at most text_len+1 iterations (one per separator + final piece).
{_iters} math "{_text_len}+1"

{r} repeat {_iters}
	if {_done} = "0"
		{_pos} strpos {_remaining} {_sep}
		if {_pos} > "-1"
			# Separator found: slice off the part before it.
			{_part} substr 0 {_pos} {_remaining}
			{return/{_count}} = {_part}
			{_concat} = "{_concat}{_part}"
			{_count} math "{_count}+1"
			{_after} math "{_pos}+{_sep_len}"
			{_rem_len} = {_remaining/length}
			{_remaining} substr {_after} {_rem_len} {_remaining}
		else
			# No more separators: store the final piece.
			{return/{_count}} = {_remaining}
			{_concat} = "{_concat}{_remaining}"
			{_count} math "{_count}+1"
			{_done} = "1"

{return} = {_concat}
{return/count} = {_count}
