<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BUCL Playground</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg:       #0f1117;
      --surface:  #1a1d27;
      --border:   #2d3147;
      --accent:   #7c6af7;
      --accent2:  #56cfb2;
      --text:     #e0e2f0;
      --muted:    #7a7f9e;
      --error:    #f06464;
      --success:  #56cfb2;
      --font-mono: "Fira Code", "Cascadia Code", "Consolas", monospace;
      --radius:   8px;
    }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* ── Header ── */
    header {
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      padding: 1rem 2rem;
      display: flex;
      align-items: center;
      gap: 1.2rem;
    }
    header h1 {
      font-size: 1.4rem;
      font-weight: 700;
      letter-spacing: -0.02em;
    }
    header h1 span { color: var(--accent); }
    header .tagline {
      color: var(--muted);
      font-size: 0.85rem;
    }
    #status-badge {
      margin-left: auto;
      padding: 0.3rem 0.75rem;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 600;
      background: #2a2f4a;
      color: var(--muted);
      transition: all 0.3s;
    }
    #status-badge.ready   { background: #1a3a2e; color: var(--success); }
    #status-badge.error   { background: #3a1a1a; color: var(--error); }

    /* ── Main layout ── */
    main {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: auto 1fr;
      gap: 1.5rem;
      padding: 1.5rem 2rem;
      max-width: 1400px;
      width: 100%;
      margin: 0 auto;
    }

    /* ── Examples bar ── */
    .examples-bar {
      grid-column: 1 / -1;
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }
    .examples-bar label {
      color: var(--muted);
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      margin-right: 0.25rem;
    }
    .example-btn {
      background: var(--surface);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 0.35rem 0.85rem;
      border-radius: 20px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: border-color 0.2s, color 0.2s;
    }
    .example-btn:hover { border-color: var(--accent); color: var(--accent); }

    /* ── Editor panel ── */
    .panel {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .panel-header {
      display: flex;
      align-items: center;
      padding: 0.6rem 1rem;
      border-bottom: 1px solid var(--border);
      gap: 0.5rem;
    }
    .panel-header h2 {
      font-size: 0.78rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }
    .panel-header .dot {
      width: 8px; height: 8px;
      border-radius: 50%;
      background: var(--accent);
    }
    .panel-header .dot.out { background: var(--accent2); }

    #editor {
      flex: 1;
      resize: none;
      background: transparent;
      border: none;
      outline: none;
      padding: 1rem;
      font-family: var(--font-mono);
      font-size: 0.88rem;
      line-height: 1.65;
      color: var(--text);
      tab-size: 4;
      min-height: 340px;
    }
    #editor::placeholder { color: var(--muted); }

    /* ── Output panel ── */
    #output {
      flex: 1;
      padding: 1rem;
      font-family: var(--font-mono);
      font-size: 0.88rem;
      line-height: 1.65;
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-word;
      color: var(--accent2);
      min-height: 340px;
    }
    #output.empty      { color: var(--muted); font-style: italic; }
    #output.has-error  { color: var(--error); }

    /* ── Run button ── */
    .run-row {
      padding: 0.6rem 1rem;
      border-top: 1px solid var(--border);
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
    }
    #run-btn {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 0.5rem 1.4rem;
      border-radius: 6px;
      font-size: 0.88rem;
      font-weight: 600;
      cursor: pointer;
      transition: opacity 0.2s;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }
    #run-btn:hover     { opacity: 0.85; }
    #run-btn:disabled  { opacity: 0.4; cursor: default; }
    #clear-btn {
      background: transparent;
      color: var(--muted);
      border: 1px solid var(--border);
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-size: 0.88rem;
      cursor: pointer;
    }
    #clear-btn:hover { border-color: var(--accent); color: var(--accent); }

    /* ── Footer ── */
    footer {
      text-align: center;
      padding: 0.75rem;
      font-size: 0.75rem;
      color: var(--muted);
      border-top: 1px solid var(--border);
    }
    footer a { color: var(--accent); text-decoration: none; }

    /* ── Responsive ── */
    @media (max-width: 768px) {
      main { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>

<header>
  <h1><span>BUCL</span> Playground</h1>
  <span class="tagline">BatchUp Command Line &mdash; runs in your browser</span>
  <span id="status-badge">loading&hellip;</span>
</header>

<main>
  <div class="examples-bar">
    <label>Examples:</label>
    <button class="example-btn" data-example="hello">Hello World</button>
    <button class="example-btn" data-example="fizzbuzz">FizzBuzz</button>
    <button class="example-btn" data-example="strings">Strings</button>
    <button class="example-btn" data-example="loops">Loops</button>
    <button class="example-btn" data-example="random">Random</button>
    <button class="example-btn" data-example="fibonacci">Fibonacci</button>
  </div>

  <!-- Editor -->
  <div class="panel">
    <div class="panel-header">
      <div class="dot"></div>
      <h2>Editor</h2>
    </div>
    <textarea id="editor" spellcheck="false" placeholder="# Write your BUCL script here&#10;{output} = &quot;Hello, World!&quot;"></textarea>
    <div class="run-row">
      <button id="clear-btn">Clear</button>
      <button id="run-btn" disabled>
        <svg width="13" height="13" viewBox="0 0 12 12" fill="currentColor">
          <polygon points="2,1 10,6 2,11"/>
        </svg>
        Run
      </button>
    </div>
  </div>

  <!-- Output -->
  <div class="panel">
    <div class="panel-header">
      <div class="dot out"></div>
      <h2>Output</h2>
    </div>
    <pre id="output" class="empty">// output appears here</pre>
  </div>
</main>

<footer>
  BUCL is open source &mdash;
  <a href="https://github.com/terraloader/bucl-rust" target="_blank">github.com/terraloader/bucl-rust</a>
</footer>

<script>
// ---------------------------------------------------------------------------
// Example scripts
// ---------------------------------------------------------------------------
const EXAMPLES = {
  hello: `# Hello, World!
{output} = "Hello, World!"

{name} = "BUCL"
{output} = "Welcome to {name}!"

# String interpolation
{lang} = "JavaScript"
{output} = "Running in {lang}"`,

  fizzbuzz: `# FizzBuzz 1-20
{i} repeat 20
    {fizz} math "{i/index} % 3"
    {buzz} math "{i/index} % 5"
    if {fizz} = "0"
        if {buzz} = "0"
            {output} = "FizzBuzz"
        else
            {output} = "Fizz"
    elseif {buzz} = "0"
        {output} = "Buzz"
    else
        {output} = "{i/index}"`,

  strings: `# String functions
{rev} reverse "Hello, World!"
{output} = "reversed: {rev}"

{sub} substr 0 5 "Hello, World!"
{output} = "substr(0,5): {sub}"

{pos} strpos "Hello, World!" "World"
{output} = "strpos 'World': {pos}"

{len} length "Hello" " " "World"
{output} = "length: {len}"

# implode / explode
{joined} implode " | " "alpha" "beta" "gamma"
{output} = "implode: {joined}"

{parts} explode "," "one,two,three,four"
{output} = "explode[0]: {parts/0}"
{output} = "explode[1]: {parts/1}"
{output} = "explode[2]: {parts/2}"
{output} = "explode[3]: {parts/3}"`,

  loops: `# repeat loop
{output} = "-- repeat --"
{r} repeat 5
    {output} = "  step {r/index}"

# each loop
{output} = "-- each --"
{e} each "Alice" "Bob" "Charlie" "Dana"
    {output} = "  Hello, {e/value}!"

# if / elseif / else
{output} = "-- if/elseif/else --"
{x} = "b"
if {x} = "a"
    {output} = "  x is a"
elseif {x} = "b"
    {output} = "  x is b"
else
    {output} = "  x is something else"

# math
{output} = "-- math --"
{result} math "(2 + 3) * 4"
{output} = "  (2+3)*4 = {result}"`,

  random: `# Random numbers
{a} random 1 6
{output} = "dice roll: {a}"

{b} random 1 100
{output} = "1-100: {b}"

# Pick a random greeting
{pick} random 0 2
if {pick} = "0"
    {word} = "Hello"
elseif {pick} = "1"
    {word} = "Hi"
else
    {word} = "Hey"
{output} = "{word}, from a random greeting!"`,

  fibonacci: `# Fibonacci sequence (first 12 terms)
{a} = "0"
{b} = "1"
{output} = "Fibonacci: {a}, {b}"
{i} repeat 10
    {next} math "{a} + {b}"
    {output} = "  -> {next}"
    {a} = {b}
    {b} = {next}`,
};

// ---------------------------------------------------------------------------
// BUCL interpreter — pure JavaScript port of the Rust implementation
// ---------------------------------------------------------------------------

// ── Lexer ──────────────────────────────────────────────────────────────────

function tokenizeLine(line) {
  const indent = line.length - line.trimStart().length;
  const content = line.trim();
  if (!content || content.startsWith('#')) return null;
  const tokens = [];
  let i = 0;
  while (i < content.length) {
    const c = content[i];
    if (c === ' ' || c === '\t') { i++; continue; }
    if (c === '{') {
      i++;
      let name = '', depth = 1;
      while (i < content.length) {
        if (content[i] === '{') { depth++; name += '{'; i++; }
        else if (content[i] === '}') { if (--depth === 0) { i++; break; } name += '}'; i++; }
        else name += content[i++];
      }
      tokens.push({ type: 'variable', value: name });
    } else if (c === '"') {
      i++;
      let s = '';
      while (i < content.length && content[i] !== '"') {
        if (content[i] === '\\' && i + 1 < content.length) {
          const nc = content[++i];
          s += nc === '"' ? '"' : nc === 'n' ? '\n' : nc === 't' ? '\t' : nc === '\\' ? '\\' : ('\\' + nc);
        } else s += content[i];
        i++;
      }
      if (i < content.length) i++;
      tokens.push({ type: 'quoted', value: s });
    } else {
      let word = '';
      while (i < content.length && content[i] !== ' ' && content[i] !== '\t') word += content[i++];
      tokens.push({ type: 'bare', value: word });
    }
  }
  return tokens.length > 0 ? { indent, tokens } : null;
}

function tokenize(src) { return src.split('\n').map(tokenizeLine).filter(Boolean); }

// ── Parser ─────────────────────────────────────────────────────────────────

function parse(src) {
  const p = { lines: tokenize(src), cursor: 0 };
  return parseBlock(p, 0);
}

function isCont(p, i) {
  const l = p.lines[i];
  if (!l) return false;
  const f = l.tokens[0];
  return f && f.type === 'bare' && (f.value === 'elseif' || f.value === 'else');
}

function parseBlock(p, ei) {
  const stmts = [];
  while (p.cursor < p.lines.length) {
    const ind = p.lines[p.cursor].indent;
    if (ind < ei) break;
    if (ind > ei) throw new Error('unexpected indent: got ' + ind + ', expected ' + ei);
    if (isCont(p, p.cursor)) break;
    stmts.push(parseStmt(p, ei));
  }
  return stmts;
}

function parseStmt(p, ci) {
  const line = p.lines[p.cursor++];
  const parts = extractParts(line.tokens);
  let block = null;
  if (p.cursor < p.lines.length && p.lines[p.cursor].indent > ci)
    block = parseBlock(p, p.lines[p.cursor].indent);
  let continuation = null;
  if ((parts.fn === 'if' || parts.fn === 'elseif') && p.cursor < p.lines.length &&
      isCont(p, p.cursor) && p.lines[p.cursor].indent === ci)
    continuation = parseStmt(p, ci);
  return { target: parts.target, fn: parts.fn, args: parts.args, block: block, continuation: continuation };
}

function extractParts(tokens) {
  let i = 0;
  const first = tokens[i++];
  let target = null, fn;
  if (first.type === 'variable') {
    const next = tokens[i++];
    if (!next || next.type !== 'bare') throw new Error('expected function name after {' + first.value + '}');
    target = first.value; fn = next.value;
  } else if (first.type === 'bare') {
    fn = first.value;
  } else throw new Error('line cannot start with a string literal');
  return { target: target, fn: fn, args: tokens.slice(i) };
}

// ── Math expression evaluator ──────────────────────────────────────────────

function mathEval(s) {
  let p = 0;
  function ws() { while (p < s.length && (s[p] === ' ' || s[p] === '\t')) p++; }
  function primary() {
    ws();
    if (s[p] === '(') {
      p++;
      var v = addSub(); ws();
      if (s[p] !== ')') throw new Error('expected )');
      p++; return v;
    }
    var n = '';
    while (p < s.length && (s[p] >= '0' && s[p] <= '9' || s[p] === '.')) n += s[p++];
    if (!n) throw new Error('expected number at position ' + p);
    return parseFloat(n);
  }
  function unary() {
    ws();
    if (s[p] === '-') { p++; return -primary(); }
    if (s[p] === '+') p++;
    return primary();
  }
  function mulDiv() {
    var v = unary();
    while (true) {
      ws();
      if (s[p] === '*') { p++; v *= unary(); }
      else if (s[p] === '/') { p++; var r = unary(); if (r === 0) throw new Error('division by zero'); v /= r; }
      else if (s[p] === '%') { p++; var r = unary(); if (r === 0) throw new Error('modulo by zero'); v %= r; }
      else break;
    }
    return v;
  }
  function addSub() {
    var v = mulDiv();
    while (true) {
      ws();
      if (s[p] === '+') { p++; v += mulDiv(); }
      else if (s[p] === '-') { p++; v -= mulDiv(); }
      else break;
    }
    return v;
  }
  var result = addSub(); ws();
  if (p < s.length) throw new Error('unexpected character \'' + s[p] + '\'');
  return result;
}

// ── Evaluator ──────────────────────────────────────────────────────────────

function BuclEval() {
  this.vars = {};
  this.out  = [];
  this.fns  = {};
}

BuclEval.prototype.setVar = function(name, val) {
  if (name === 'output') this.out.push(val);
  if (name.indexOf('/') === -1) {
    this.vars[name + '/length'] = String(Array.from(val).length);
    this.vars[name + '/count']  = '1';
  }
  this.vars[name] = val;
};

BuclEval.prototype.getVar = function(name) {
  if (name.indexOf('{') !== -1) return this.getVar(this.interp(name));
  if (Object.prototype.hasOwnProperty.call(this.vars, name)) return this.vars[name];
  var sl = name.indexOf('/');
  if (sl !== -1) {
    var par = name.slice(0, sl), idx = name.slice(sl + 1);
    var n = parseInt(idx);
    if (Number.isInteger(n) && n >= 0 && String(n) === idx) {
      var cnt = parseInt(this.vars[par + '/count'] || '0') || 0;
      if (cnt === 1) {
        var ch = Array.from(this.vars[par] || '');
        return n < ch.length ? ch[n] : '';
      }
    }
  }
  return '';
};

BuclEval.prototype.getVarForInterp = function(name) {
  var rn = name.indexOf('{') !== -1 ? this.interp(name) : name;
  if (rn.indexOf('/') === -1) {
    var cnt = parseInt(this.vars[rn + '/count'] || '0') || 0;
    if (cnt > 1) {
      var parts = [];
      for (var i = 0; i < cnt; i++) parts.push(this.vars[rn + '/' + i] || '');
      return parts.join(' ');
    }
  }
  return this.getVar(rn);
};

BuclEval.prototype.interp = function(s) {
  var r = '', i = 0;
  while (i < s.length) {
    if (s[i] !== '{') { r += s[i++]; continue; }
    i++;
    var vn = '', closed = false, d = 1;
    while (i < s.length) {
      if (s[i] === '{') { d++; vn += '{'; i++; }
      else if (s[i] === '}') { if (--d === 0) { closed = true; i++; break; } vn += '}'; i++; }
      else vn += s[i++];
    }
    r += closed ? this.getVarForInterp(vn) : '{' + vn;
  }
  return r;
};

BuclEval.prototype.evalP = function(p) {
  if (p.type === 'quoted')   return this.interp(p.value);
  if (p.type === 'variable') return this.getVar(p.value);
  return p.value;
};

BuclEval.prototype.evalPs = function(params) {
  var r = [];
  for (var pi = 0; pi < params.length; pi++) {
    var p = params[pi];
    if (p.type === 'variable') {
      var rn = p.value.indexOf('{') !== -1 ? this.interp(p.value) : p.value;
      if (rn.indexOf('/') === -1) {
        var cnt = parseInt(this.vars[rn + '/count'] || '0') || 0;
        if (cnt > 1) {
          for (var j = 0; j < cnt; j++) r.push(this.vars[rn + '/' + j] || '');
          continue;
        }
      }
      r.push(this.getVar(p.value));
    } else {
      r.push(this.evalP(p));
    }
  }
  return r;
};

BuclEval.prototype.runStmts = function(stmts) {
  for (var i = 0; i < stmts.length; i++) this.exec(stmts[i]);
};

BuclEval.prototype.exec = function(stmt) {
  var args = this.evalPs(stmt.args);
  var tgt = stmt.target;
  if (tgt && tgt.indexOf('{') !== -1) tgt = this.interp(tgt);
  var res = this.dispatch(stmt.fn, tgt, args, stmt.block, stmt.continuation);
  if (res !== undefined && res !== null && tgt !== null) this.setVar(tgt, res);
};

BuclEval.prototype.dispatch = function(fn, tgt, args, block, cont) {
  var self = this;
  switch (fn) {
    case '=':        return this.doAssign(tgt, args);
    case 'if':
    case 'elseif':   return this.doIf(args, block, cont);
    case 'else':     if (block) this.runStmts(block); return undefined;
    case 'repeat':   return this.doRepeat(tgt, args, block);
    case 'each':     return this.doEach(tgt, args, block);
    case 'math': {
      var v = mathEval(args.join(''));
      return (v % 1 === 0 && Math.abs(v) < 1e15) ? String(Math.trunc(v)) : String(v);
    }
    case 'random': {
      var mn = 0, mx = Number.MAX_SAFE_INTEGER;
      if (args.length === 1) mx = parseInt(args[0]);
      else if (args.length >= 2) { mn = parseInt(args[0]); mx = parseInt(args[1]); }
      return String(Math.floor(Math.random() * (mx - mn + 1)) + mn);
    }
    case 'length':
      return String(args.reduce(function(s, a) { return s + Array.from(a).length; }, 0));
    case 'count':    return String(args.length);
    case 'substr': {
      if (args.length < 3) throw new Error('substr: requires start, length, string');
      var s = parseInt(args[0]), l = parseInt(args[1]), ch = Array.from(args[2]);
      var st = Math.min(s, ch.length);
      return ch.slice(st, Math.min(st + l, ch.length)).join('');
    }
    case 'strpos': {
      if (args.length < 2) throw new Error('strpos: requires text and needle');
      var pos = args[0].indexOf(args[1]);
      return pos < 0 ? '-1' : String(args[0].slice(0, pos).length);
    }
    case 'setvar':
      if (args.length >= 2) this.setVar(args[0], args[1]);
      return undefined;
    case 'getvar':   return args.length ? this.getVar(args[0]) : '';
    case 'readfile': return '[error] readfile: not available in browser';
    case 'writefile':return '[error] writefile: not available in browser';
    default:         return this.callBuclFn(fn, tgt, args);
  }
};

BuclEval.prototype.doAssign = function(tgt, args) {
  var v = args.join('');
  if (!tgt) return v;
  this.setVar(tgt, v);
  if (args.length > 1) {
    this.vars[tgt + '/count'] = String(args.length);
    for (var i = 0; i < args.length; i++) this.vars[tgt + '/' + i] = args[i];
  }
  return undefined;
};

BuclEval.prototype.doIf = function(args, block, cont) {
  var l = args[0], op = args[1], r = args[2];
  var ln = parseFloat(l), rn = parseFloat(r), num = !isNaN(ln) && !isNaN(rn);
  var cond =
    op === '='  ? l === r :
    op === '!=' ? l !== r :
    op === '>'  ? (num ? ln > rn  : l > r)  :
    op === '<'  ? (num ? ln < rn  : l < r)  :
    op === '>=' ? (num ? ln >= rn : l >= r) :
    op === '<=' ? (num ? ln <= rn : l <= r) : false;
  if (cond) { if (block) this.runStmts(block); }
  else if (cont) this.exec(cont);
  return undefined;
};

BuclEval.prototype.doRepeat = function(tgt, args, block) {
  var px = tgt || 'r', n = parseInt(args[0]);
  if (isNaN(n)) throw new Error('repeat: \'' + args[0] + '\' is not a valid count');
  this.setVar(px, String(n));
  this.vars[px + '/count'] = String(n);
  if (block) {
    for (var i = 0; i < n; i++) {
      this.vars[px + '/index'] = String(i + 1);
      this.runStmts(block);
    }
  }
  return undefined;
};

BuclEval.prototype.doEach = function(tgt, args, block) {
  var px = tgt || 'e';
  this.setVar(px, String(args.length));
  this.vars[px + '/count'] = String(args.length);
  this.vars[px + '/length'] = String(args.reduce(function(s, a) { return s + Array.from(a).length; }, 0));
  for (var i = 0; i < args.length; i++) this.vars[px + '/' + i] = args[i];
  if (block) {
    for (var i = 0; i < args.length; i++) {
      this.vars[px + '/index'] = String(i);
      this.vars[px + '/value'] = args[i];
      this.runStmts(block);
    }
  }
  return undefined;
};

BuclEval.prototype.callBuclFn = function(name, tgt, args) {
  var src = this.fns[name];
  if (!src) throw new Error('unknown function: ' + name);
  var stmts = parse(src);
  var child = new BuclEval();
  child.fns = this.fns;
  child.vars['argc'] = String(args.length);
  for (var i = 0; i < args.length; i++) child.vars[String(i)] = args[i];
  child.vars['args'] = args.join('');
  child.vars['args/count'] = String(args.length);
  child.vars['args/length'] = String(args.reduce(function(s, a) { return s + Array.from(a).length; }, 0));
  for (var i = 0; i < args.length; i++) child.vars['args/' + i] = args[i];
  if (tgt) child.vars['target'] = tgt;
  child.runStmts(stmts);
  for (var i = 0; i < child.out.length; i++) this.out.push(child.out[i]);
  if (tgt) {
    var keys = Object.keys(child.vars);
    for (var i = 0; i < keys.length; i++) {
      if (keys[i].indexOf('return/') === 0)
        this.vars[tgt + '/' + keys[i].slice(7)] = child.vars[keys[i]];
    }
  }
  return child.vars['return'];
};

// ── Standard library (embedded BUCL source) ───────────────────────────────

var BUCL_STDLIB = {
  reverse: [
    '{_text} = ""',
    '{r} repeat {argc}',
    '\t{_i} math "{r/index}-1"',
    '\t{_arg} getvar {_i}',
    '\t{_text} = "{_text}{_arg}"',
    '{_len} length {_text}',
    '{_result} = ""',
    '{r} repeat {_len}',
    '\t{_i} math "{_len}-{r/index}"',
    '\t{_char} substr {_i} 1 {_text}',
    '\t{_result} = "{_result}{_char}"',
    '{return} = {_result}'
  ].join('\n'),

  explode: [
    '{_sep} = {0}',
    '{_text} = {1}',
    '{_sep_len} length {_sep}',
    '{_text_len} length {_text}',
    '{_count} = "0"',
    '{_done} = "0"',
    '{_remaining} = {1}',
    '{_iters} math "{_text_len}+1"',
    '{r} repeat {_iters}',
    '\tif {_done} = "0"',
    '\t\t{_pos} strpos {_remaining} {_sep}',
    '\t\tif {_pos} > "-1"',
    '\t\t\t{_part} substr 0 {_pos} {_remaining}',
    '\t\t\t{return/{_count}} = {_part}',
    '\t\t\t{_count} math "{_count}+1"',
    '\t\t\t{_after} math "{_pos}+{_sep_len}"',
    '\t\t\t{_rem_len} length {_remaining}',
    '\t\t\t{_remaining} substr {_after} {_rem_len} {_remaining}',
    '\t\telse',
    '\t\t\t{return/{_count}} = {_remaining}',
    '\t\t\t{_count} math "{_count}+1"',
    '\t\t\t{_done} = "1"',
    '{return} = {_count}'
  ].join('\n'),

  implode: [
    '{_sep} = {args/0}',
    '{_n_items} math "{argc}-1"',
    'if {_n_items} = "0"',
    '\t{return} = ""',
    'else',
    '\t{_result} = {args/1}',
    '\t{_remaining} math "{_n_items}-1"',
    '\t{r} repeat {_remaining}',
    '\t\t{_i} math "{r/index}+1"',
    '\t\t{_result} = "{_result}{_sep}{args/{_i}}"',
    '\t{return} = {_result}'
  ].join('\n'),

  maxlength: [
    '{_max} = "0"',
    '{r} repeat {argc}',
    '\t{_i} math "{r/index}-1"',
    '\t{_item} getvar {_i}',
    '\t{_len} length {_item}',
    '\tif {_len} > {_max}',
    '\t\t{_max} = {_len}',
    '{return} = {_max}'
  ].join('\n'),

  slice: [
    '{_start} = {0}',
    '{_end} = {1}',
    '{_item_count} math "{argc}-2"',
    'if {_start} < "0"',
    '\t{_start} math "{_item_count}+{_start}"',
    'if {_end} < "0"',
    '\t{_end} math "{_item_count}+{_end}"',
    '{_result} = ""',
    '{r} repeat {_item_count}',
    '\t{_i} math "{r/index}-1"',
    '\t{_actual} math "{_i}+2"',
    '\tif {_i} >= {_start}',
    '\t\tif {_i} < {_end}',
    '\t\t\t{_item} getvar {_actual}',
    '\t\t\tif {_result} = ""',
    '\t\t\t\t{_result} = {_item}',
    '\t\t\telse',
    '\t\t\t\t{_result} = "{_result} {_item}"',
    '{return} = {_result}'
  ].join('\n')
};

// ── Public entry point ─────────────────────────────────────────────────────

function buclRun(source) {
  try {
    var ev = new BuclEval();
    var keys = Object.keys(BUCL_STDLIB);
    for (var i = 0; i < keys.length; i++) ev.fns[keys[i]] = BUCL_STDLIB[keys[i]];
    ev.runStmts(parse(source));
    return ev.out.join('\n');
  } catch (e) {
    return '[error] ' + e.message;
  }
}

// ---------------------------------------------------------------------------
// UI
// ---------------------------------------------------------------------------
var statusBadge = document.getElementById('status-badge');
var runBtn      = document.getElementById('run-btn');
var editor      = document.getElementById('editor');
var outputEl    = document.getElementById('output');

// JS interpreter is always available — mark ready immediately.
statusBadge.textContent = 'ready';
statusBadge.className   = 'ready';
runBtn.disabled = false;

runBtn.addEventListener('click', function() {
  var src = editor.value;
  try {
    var out = buclRun(src);
    if (!out.trim()) {
      outputEl.textContent = '// (no output)';
      outputEl.className   = 'empty';
    } else {
      outputEl.textContent = out;
      outputEl.className   = (out.indexOf('[error]') === 0 || out.indexOf('[parse error]') === 0)
        ? 'has-error' : '';
    }
  } catch (err) {
    outputEl.textContent = '[runtime error] ' + err.message;
    outputEl.className   = 'has-error';
  }
});

document.getElementById('clear-btn').addEventListener('click', function() {
  outputEl.textContent = '// output appears here';
  outputEl.className   = 'empty';
});

// Ctrl/Cmd+Enter to run
editor.addEventListener('keydown', function(e) {
  if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
    e.preventDefault();
    runBtn.click();
  }
  if (e.key === 'Tab') {
    e.preventDefault();
    var start = editor.selectionStart;
    var end   = editor.selectionEnd;
    editor.value = editor.value.slice(0, start) + '\t' + editor.value.slice(end);
    editor.selectionStart = editor.selectionEnd = start + 1;
  }
});

// Example buttons
document.querySelectorAll('.example-btn').forEach(function(btn) {
  btn.addEventListener('click', function() {
    var key = btn.dataset.example;
    if (EXAMPLES[key]) {
      editor.value = EXAMPLES[key];
      outputEl.textContent = '// output appears here';
      outputEl.className   = 'empty';
    }
  });
});

// Pre-load hello example
editor.value = EXAMPLES.hello;
</script>

</body>
</html>
